from datetime import datetime
from typing import Optional, Dict, Any, List
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy import (
    String, Integer, Text, ForeignKey, func, Float, Boolean
)
from orgmind.storage.models import Base, JSON_TYPE, TIMESTAMP_TYPE

class DecisionTraceModel(Base):
    """
    Captures the execution trace of a decision/action taken by the system.
    """
    __tablename__ = "decision_traces"

    id: Mapped[str] = mapped_column(String, primary_key=True)
    
    # What triggered this?
    rule_id: Mapped[Optional[str]] = mapped_column(String, index=True)
    trigger_event_id: Mapped[Optional[str]] = mapped_column(String, index=True) # ID of the event that triggered the rule
    
    # What was done?
    action_type: Mapped[str] = mapped_column(String, nullable=False, index=True)
    input_payload: Mapped[Dict[str, Any]] = mapped_column(JSON_TYPE, nullable=False)
    output_payload: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSON_TYPE)
    
    # Performance & Status
    status: Mapped[str] = mapped_column(String, server_default='success', index=True) # success, failure
    error_message: Mapped[Optional[str]] = mapped_column(Text)
    latency_ms: Mapped[Optional[float]] = mapped_column(Float)
    
    # When?
    timestamp: Mapped[datetime] = mapped_column(TIMESTAMP_TYPE, server_default=func.now(), index=True)
    
    # Context
    snapshot_id: Mapped[Optional[str]] = mapped_column(ForeignKey("context_snapshots.id"), nullable=True)
    
    # Relationships
    snapshot: Mapped[Optional["ContextSnapshotModel"]] = relationship(back_populates="traces")


class ContextSnapshotModel(Base):
    """
    Captures the state of the world (entities and graph) at the time of a decision.
    """
    __tablename__ = "context_snapshots"

    id: Mapped[str] = mapped_column(String, primary_key=True)
    
    # What entities were involved?
    entity_states: Mapped[Dict[str, Any]] = mapped_column(JSON_TYPE, nullable=False) # Map of entity_id -> state dict
    
    # Graph context (2-hop neighborhood usually)
    graph_neighborhood: Mapped[Dict[str, Any]] = mapped_column(JSON_TYPE, nullable=False) # Node/Edge list or similar structure
    
    # When?
    timestamp: Mapped[datetime] = mapped_column(TIMESTAMP_TYPE, server_default=func.now())
    
    # Relationships
    traces: Mapped[List["DecisionTraceModel"]] = relationship(back_populates="snapshot")


class InferenceRuleModel(Base):
    """
    Rules for inferring context from traces and snapshots.
    e.g. "If priority changed from Low to High, suggest 'Urgency Increase'"
    """
    __tablename__ = "inference_rules"

    id: Mapped[str] = mapped_column(String, primary_key=True)
    name: Mapped[str] = mapped_column(String, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text)
    
    # Logic defining when this rule applies
    # Could be a simple JSON structure or JsonLogic
    condition_logic: Mapped[Dict[str, Any]] = mapped_column(JSON_TYPE, nullable=False)
    
    # Priority for conflict resolution
    priority: Mapped[int] = mapped_column(Integer, default=0)
    
    is_active: Mapped[bool] = mapped_column(Boolean, default=True)


class ContextSuggestionModel(Base):
    """
    A specific suggestion for WHY a decision was made, linked to a trace.
    Generated by either deterministic rules or AI.
    """
    __tablename__ = "context_suggestions"

    id: Mapped[str] = mapped_column(String, primary_key=True)
    
    # The trace this suggestion is for
    trace_id: Mapped[str] = mapped_column(ForeignKey("decision_traces.id"), nullable=False, index=True)
    
    # The suggested context/reason
    suggestion_text: Mapped[str] = mapped_column(Text, nullable=False)
    
    # Source of the suggestion
    source: Mapped[str] = mapped_column(String, nullable=False) # e.g. "rule:urgent_update", "ai:llm"
    
    # Confidence score (0.0 to 1.0)
    confidence: Mapped[float] = mapped_column(Float, default=1.0)
    
    # User feedback status
    status: Mapped[str] = mapped_column(String, default="pending", index=True) # pending, accepted, rejected
    
    # Timestamps
    created_at: Mapped[datetime] = mapped_column(TIMESTAMP_TYPE, server_default=func.now())
    updated_at: Mapped[datetime] = mapped_column(TIMESTAMP_TYPE, server_default=func.now(), onupdate=func.now())

    # Relationships
    trace: Mapped["DecisionTraceModel"] = relationship()
